<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 作用域
        /* 
            局部作用域
                函数作用域
                    函数内部
                块作用域
                    被 {}包裹的代码
                    var不会产生块级作用域
                    不同代码块之间的变量无法互相访问

            全局作用域
                在 script标签和.js文件的最外层
                ！尽可能少的声明 全局作用域

            作用域链
                底层变量的查找机制
                优先查找当前作用域
                逐级查找父级作用域
                子作用域可以访问父作用域，父作用域无法访问子作用域

            垃圾回收机制
                GC
                内存生命周期
                内存分配
                    声明变量、函数、对象的时候，系统自动分配内存
                内存使用
                    使用变量、函数等
                内存回收
                        使用完毕，垃圾回收器自动回收不再使用的内存（全局变量不被回收）
                内存泄漏
                    程序中分配的内存由于某种原因程序为释放或无法释放叫做内存泄漏
                
                算法说明
                    栈：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
                    堆：由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放在堆里面

                引用计数法
                    跟踪记录被引用的次数
                    如果被引用一次就记录一次，多次引用会累加
                    减少一个引用就减一
                    如果引用次数为 0，则释放内存
                    // 致命问题：嵌套引用（循环引用）如果两个对象相互引用，尽管不再使用，但也不会进行回收，导致内存泄漏
                const arr = [1,5,7,3]
                arr = null // 无引用次数
                // 释放内存

                标记清除法
                    将不再使用的对象，定义为 “无法达到的对象”
                    从跟出发，定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的
                    那些无法从根部出发触及到的对象被标记为不再使用，稍后进行回收。
                    核心思路：从根部扫描对象，能查找到的就是使用的，查找不到的就是要回收

            闭包：Closure
                可能引起 内存泄漏
                一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域
                内层函数 + 外层函数的变量
                内层函数使用（捆绑在一起）外层函数的变量叫做闭包
                作用：
                    封闭数据，提供操作，外部也可以访问函数内部的变量
                应用：
                    实现数据的私有
                全局作用域容易被修改
        */
       function outer() {
            let a = 10
            function fn() {
                console.log(a)
            }
            return fn
       }
    //    outer()
    const fun = outer()
    // 调用函数
    fun()

    // 变量提升
    /* 
       缺陷 var
       代码执行前，在当前作用域下，将所有使用 var声明的变量，提升到当前作用域的最前面
       只提升声明，不提升赋值
    */
    </script>
</body>
</html>